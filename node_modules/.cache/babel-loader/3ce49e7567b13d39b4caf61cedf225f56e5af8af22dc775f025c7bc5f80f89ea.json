{"ast":null,"code":"var _s = $RefreshSig$();\nimport { createContext, useEffect, useState } from 'react';\nimport qs from 'qs';\nfunction createResponseContext(initialState) {\n  return /*#__PURE__*/createContext(initialState);\n}\nfunction isNotEmpty(obj) {\n  return obj !== undefined && obj !== null && obj !== '';\n}\n\n// Example: page=1&items_per_page=10&sort=id&order=desc&search=a&filter_name=a&filter_online=false\nfunction stringifyRequestQuery(state) {\n  const pagination = qs.stringify(state, {\n    filter: ['page', 'items_per_page'],\n    skipNulls: true\n  });\n  const sort = qs.stringify(state, {\n    filter: ['sort', 'order'],\n    skipNulls: true\n  });\n  const search = isNotEmpty(state.search) ? qs.stringify(state, {\n    filter: ['search'],\n    skipNulls: true\n  }) : '';\n  const filter = state.filter ? Object.entries(state.filter).filter(obj => isNotEmpty(obj[1])).map(obj => {\n    return `filter_${obj[0]}=${obj[1]}`;\n  }).join('&') : '';\n  return [pagination, sort, search, filter].filter(f => f).join('&').toLowerCase();\n}\nfunction parseRequestQuery(query) {\n  const cache = qs.parse(query);\n  return cache;\n}\nfunction calculatedGroupingIsDisabled(isLoading, data) {\n  if (isLoading) {\n    return true;\n  }\n  return !data || !data.length;\n}\nfunction calculateIsAllDataSelected(data, selected) {\n  if (!data) {\n    return false;\n  }\n  return data.length > 0 && data.length === selected.length;\n}\nfunction groupingOnSelect(id, selected, setSelected) {\n  if (!id) {\n    return;\n  }\n  if (selected.includes(id)) {\n    setSelected(selected.filter(itemId => itemId !== id));\n  } else {\n    const updatedSelected = [...selected];\n    updatedSelected.push(id);\n    setSelected(updatedSelected);\n  }\n}\nfunction groupingOnSelectAll(isAllSelected, setSelected, data) {\n  if (isAllSelected) {\n    setSelected([]);\n    return;\n  }\n  if (!data || !data.length) {\n    return;\n  }\n  setSelected(data.filter(item => item.id).map(item => item.id));\n}\n\n// Hook\nfunction useDebounce(value, delay) {\n  _s();\n  // State and setters for debounced value\n  const [debouncedValue, setDebouncedValue] = useState(value);\n  useEffect(() => {\n    // Update debounced value after delay\n    const handler = setTimeout(() => {\n      setDebouncedValue(value);\n    }, delay);\n    // Cancel the timeout if value changes (also on delay change or unmount)\n    // This is how we prevent debounced value from updating if value is changed ...\n    // .. within the delay period. Timeout gets cleared and restarted.\n    return () => {\n      clearTimeout(handler);\n    };\n  }, [value, delay] // Only re-call effect if value or delay changes\n  );\n\n  return debouncedValue;\n}\n_s(useDebounce, \"KDuPAtDOgxm8PU6legVJOb3oOmA=\");\nexport { createResponseContext, stringifyRequestQuery, parseRequestQuery, calculatedGroupingIsDisabled, calculateIsAllDataSelected, groupingOnSelect, groupingOnSelectAll, useDebounce, isNotEmpty };","map":{"version":3,"names":["createContext","useEffect","useState","qs","createResponseContext","initialState","isNotEmpty","obj","undefined","stringifyRequestQuery","state","pagination","stringify","filter","skipNulls","sort","search","Object","entries","map","join","f","toLowerCase","parseRequestQuery","query","cache","parse","calculatedGroupingIsDisabled","isLoading","data","length","calculateIsAllDataSelected","selected","groupingOnSelect","id","setSelected","includes","itemId","updatedSelected","push","groupingOnSelectAll","isAllSelected","item","useDebounce","value","delay","_s","debouncedValue","setDebouncedValue","handler","setTimeout","clearTimeout"],"sources":["E:/GENText/src/_metronic/helpers/crud-helper/helpers.tsx"],"sourcesContent":["import {createContext, Dispatch, SetStateAction, useEffect, useState} from 'react'\nimport qs from 'qs'\nimport {ID, QueryResponseContextProps, QueryState} from './models'\n\nfunction createResponseContext<T>(initialState: QueryResponseContextProps<T>) {\n  return createContext(initialState)\n}\n\nfunction isNotEmpty(obj: unknown) {\n  return obj !== undefined && obj !== null && obj !== ''\n}\n\n// Example: page=1&items_per_page=10&sort=id&order=desc&search=a&filter_name=a&filter_online=false\nfunction stringifyRequestQuery(state: QueryState): string {\n  const pagination = qs.stringify(state, {filter: ['page', 'items_per_page'], skipNulls: true})\n  const sort = qs.stringify(state, {filter: ['sort', 'order'], skipNulls: true})\n  const search = isNotEmpty(state.search)\n    ? qs.stringify(state, {filter: ['search'], skipNulls: true})\n    : ''\n\n  const filter = state.filter\n    ? Object.entries(state.filter as Object)\n        .filter((obj) => isNotEmpty(obj[1]))\n        .map((obj) => {\n          return `filter_${obj[0]}=${obj[1]}`\n        })\n        .join('&')\n    : ''\n\n  return [pagination, sort, search, filter]\n    .filter((f) => f)\n    .join('&')\n    .toLowerCase()\n}\n\nfunction parseRequestQuery(query: string): QueryState {\n  const cache: unknown = qs.parse(query)\n  return cache as QueryState\n}\n\nfunction calculatedGroupingIsDisabled<T>(isLoading: boolean, data: Array<T> | undefined): boolean {\n  if (isLoading) {\n    return true\n  }\n\n  return !data || !data.length\n}\n\nfunction calculateIsAllDataSelected<T>(data: Array<T> | undefined, selected: Array<ID>): boolean {\n  if (!data) {\n    return false\n  }\n\n  return data.length > 0 && data.length === selected.length\n}\n\nfunction groupingOnSelect(\n  id: ID,\n  selected: Array<ID>,\n  setSelected: Dispatch<SetStateAction<Array<ID>>>\n) {\n  if (!id) {\n    return\n  }\n\n  if (selected.includes(id)) {\n    setSelected(selected.filter((itemId) => itemId !== id))\n  } else {\n    const updatedSelected = [...selected]\n    updatedSelected.push(id)\n    setSelected(updatedSelected)\n  }\n}\n\nfunction groupingOnSelectAll<T>(\n  isAllSelected: boolean,\n  setSelected: Dispatch<SetStateAction<Array<ID>>>,\n  data?: Array<T & {id?: ID}>\n) {\n  if (isAllSelected) {\n    setSelected([])\n    return\n  }\n\n  if (!data || !data.length) {\n    return\n  }\n\n  setSelected(data.filter((item) => item.id).map((item) => item.id))\n}\n\n// Hook\nfunction useDebounce(value: string | undefined, delay: number) {\n  // State and setters for debounced value\n  const [debouncedValue, setDebouncedValue] = useState(value)\n  useEffect(\n    () => {\n      // Update debounced value after delay\n      const handler = setTimeout(() => {\n        setDebouncedValue(value)\n      }, delay)\n      // Cancel the timeout if value changes (also on delay change or unmount)\n      // This is how we prevent debounced value from updating if value is changed ...\n      // .. within the delay period. Timeout gets cleared and restarted.\n      return () => {\n        clearTimeout(handler)\n      }\n    },\n    [value, delay] // Only re-call effect if value or delay changes\n  )\n  return debouncedValue\n}\n\nexport {\n  createResponseContext,\n  stringifyRequestQuery,\n  parseRequestQuery,\n  calculatedGroupingIsDisabled,\n  calculateIsAllDataSelected,\n  groupingOnSelect,\n  groupingOnSelectAll,\n  useDebounce,\n  isNotEmpty,\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}